const { executeINSERTQuery } = require('../src/queryExecuter');
const { readCSV, writeCSV } = require('../src/csvStorage');
const fs = require('fs');
const exp = require('constants');

// Helper function to create grades.csv with initial data
async function createGradesCSV() {
    const initialData = [
        { student_id: '1', course: 'Mathematics', grade: 'A' },
        { student_id: '2', course: 'Chemistry', grade: 'B' },
        { student_id: '3', course: 'Mathematics', grade: 'C' }
    ];
    await writeCSV('grades.csv', initialData);
}

// Test to INSERT a new grade and verify
test('Execute INSERT INTO Query for grades.csv', async () => {
    // Create grades.csv with initial data
    await createGradesCSV();

    // Execute INSERT statement
    const insertQuery = `INSERT INTO grades (student_id, course, grade) VALUES ("4", "Physics", "A")`;
    await executeINSERTQuery(insertQuery);

    // Verify the new entry
    const updatedData = await readCSV('grades.csv');
    const newEntry = updatedData.find(row => row.student_id === '4' && row.course === 'Physics');
    expect(newEntry).toBeDefined();
    expect(newEntry.grade).toEqual('A');

    // Cleanup: Delete grades.csv
    fs.unlinkSync('grades.csv');
});

// Helper function to create teachers.csv with initial data
async function createTeachersCSV() {
    const initialData = [
        { id: '1', name: 'Mr. Smith', subject: 'Mathematics' },
        { id: '2', name: 'Ms. Johnson', subject: 'Chemistry' }
    ];
    await writeCSV('teachers.csv', initialData);
}

// Test to INSERT a new teacher and verify
test('Execute INSERT INTO Query for teachers with autogenerated id', async () => {
    // Create teachers.csv with initial data
    await createTeachersCSV();

    // Execute INSERT statement
    const insertQuery = `INSERT INTO teachers (name, subject) VALUES ("Dr. Brown", "Physics")`;
    await executeINSERTQuery(insertQuery);

    // Verify the new entry
    const updatedData = await readCSV('teachers.csv');
    const newEntry = updatedData.find(row => row.id === '3' && row.name === 'Dr. Brown');
    expect(newEntry).toBeDefined();
    expect(newEntry.subject).toEqual('Physics');

    const query = `INSERT INTO "public"."teachers" ("name","subject") VALUES ("test", "maths") RETURNING "public"."teachers"."id", "public"."teachers"."name", "public"."teachers"."subject"`;
    const returningData = await executeINSERTQuery(query);
    const updatedData2 = await readCSV('teachers.csv');
    const newEntry2 = updatedData2.find(row => row.id === '4' && row.name === 'test');
    expect(newEntry2).toBeDefined();
    expect(newEntry2.subject).toEqual('maths');

    expect(returningData).toEqual({
        message: 'Row inserted successfully.',
        insertedId: 4,
        returning: { id: '4', name: 'test', subject: 'maths' }
    });

    // Cleanup: Delete teachers.csv
    fs.unlinkSync('teachers.csv');
});


// Helper function to create Student.csv with initial data
async function createUserCSV() {
    const initialData = [
        { id: '1', name: 'John', age: '30' },
        { id: '2', name: 'Jane', age: '25' }
    ];
    await writeCSV('user.csv', initialData);
}

test('Execute INSERT INTO Query for users with partial columns', async () => {
    // Create Student.csv with initial data
    await createUserCSV();

    // Execute INSERT statement
    await executeINSERTQuery(`INSERT INTO "user" ("name") VALUES ("test")`);

    // Read the updated CSV content
    const updatedData = await readCSV('user.csv');

    // Check if the new entry is added correctly
    const isEntryAdded = updatedData.some(row => row.name === 'test');
    expect(isEntryAdded).toBe(true);

    // Clean up: delete Student.csv
    fs.unlinkSync('user.csv');
});
